网络编程

软件结构
C/S结构 Client/Server
客户/服务
B/S结构 Browser/Server
浏览器/服务

网络通信协议
TCP/IP
传输控制协议，最基本，最广泛的协议
应用层、传输层、[网络层]↑、数据链路层

传输层协议
UDP 用户数据报协议
特点：数据在64kb以内
TCP 面向连接的通讯协议

网络编程三要素：
协议、ip地址、端口号
IP：Internet Protocol Adderss互联网协议地址
端口号：0-65535
逻辑端口，系统随机分配，或又服务指定
由两个字节组成
1024之前的端口不能使用
80：网络端口
mysql 3306 oracle 1521
tomcat服务器 8080

TCP
需要严格区分客户端与服务器端
客户端需要主动连接服务器端
客户端与服务器段建立逻辑连接后，连接中包含一个对象（IO对象）
IO对象为字节流对象
客户端 IP：端口号 Socket类（表示客户端）
服务器 IP：端口号 ServerSocket类
[[客户端与服务器进行交互数据，需要4个IO流对象]]
服务器需要明确
1、必须明确和哪个客户端进行的交互
	服务器又一个方法 accept，获取客户端对象
2、多个客户端同时和服务器进行交互，需要使用多个IO流对象
	[服务器没有IO流，服务器获取请求的客户端对象，使用Socket提供的IO流交互]
	服务器使用客户端的字节输入流读取客户端发送的数据
	服务器使用客户端的字节输出流回写客户端发送的数据
Socket s1 =Server.accept();

java.net.Socket
TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取回写数据
套接字：包含了IP地址和端口号的网络单位（计算机）
Socket（String host int port）
	host：服务器主机的名称/IP地址
成员方法：
OutputStream  getOutputStream（）
InputStream  getInputStream（）
close（）
实现步骤：
创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号
使用Socket对象中的方法getOutputStream（）获取网络OutputStream对象
使用OutputStream对象中的方法write给服务器发送数据
使用Socket对象中的方法getInputStream（）获取网络InputStream对象
使用InputStream对象中的方法read读取服务器发送数据
释放资源（Socket）
ZY：
客户端和服务器进行交互，必须使用Socket中提供的网络流
当创建客户端对象Socket的时候，就会请求服务器和服务器握手，如果服务器没有应答则异常

java.net.ServerSocket
构造方法
ServerSocket（int port）指定端口号
成员方法
Scoket accept（）侦听并接受到此套接字的连接
实现步骤
创建服务器ServerSocket对象
使用ServerSocket对象中的方法accept，获取请求的客户端对象Socket
使用Socket对象中的方法getInputStream（）获取网络InputStream对象
使用网络InputStream对象中的方法read，读取客户端发送的数据
使用Socket对象中的方法getOutputStream()获取网络OutputStream对象
使用网络OutputStream对象中的方法write给客户端回写数据
资源释放（Socket，ServerSocket）

C/S传输
当上传文件时，C没有将结束标记传输给S，那么S中网络input中read方法将读不到结束标记（-1），S进程将被阻塞，回传数据不进行，C读取不到回传数据的结束标记，C进入阻塞状态
解决：当C上传完文件，写一个结束标记
为防止同名文件被覆盖，使用一个命名规则对文件进行命名，例如：域名+毫秒值+随机数
为了保证S一直工作，需要对accept进行死循环
使用多线程提高程序的效率


函数式接口

函数式接口指有且只有一个抽象方法的接口
@FunctionalInterface注解：函数式接口（标记至接口名上）
函数式接口一般可以作为方法的参数和返回值类型来使用
Lambda里没有生成class文件
匿名内部内生成class文件

自定义函数式接口
当参数不符合方法条件时，方法不执行（不生成方法体（因为是传接口）），性能更高
[[Runnbale可以作为函数式接口传参]]
当方法的参数是一个接口，那么我们可以传递这个接口的匿名内部类


主函数-重写接口方法/参数》方法1-参数》函数式接口-参数》方法1-方法操作后的参数/结果》主函数
public static void main(String[] args) {
        stratThread(() -> System.out.println(Thread.currentThread().getName()+"ThreadStart"));
    }

private static void stratThread(Runnable runnable) {
//将参数传递给主函数重写了方法的接口
        new Thread(runnable).start();

    }

函数式接口作为返回值
主函数-参数接口》方法1-重写接口方法》主函数接收重写方法后的接口

public static void main(String[] args) {
        String[] strings= {"asd","222222","22d","asddd"};
//方法1的返回值为重写了方法的接口
        Arrays.sort(strings,return1());
        System.out.println(Arrays.toString(strings));
    }

    private static Comparator<String> return1() {
//重写接口方法
        return (o1,o2)->o1.length()-o2.length();
    }


常用函数式接口java.util.function
Supplier接口
java.util.function.Supplier<T>  指定方法返回值的泛型<T>
Supplier<T>称为生产型接口，指定接口的泛型是说明类型，那么接口中的get方法就产生说明类型的数据

public static int getMAX(Supplier<Integer> sup){
        return sup.get();
    }

    public static void main(String[] args) {
        ArrayList<Integer> arr= new ArrayList<>();
        arr.add(100);
        //将参数传给方法1，方法1将参数传给接口，重写接口方法，将重写后的接口处理的数据传给方法1，将返回值传给主方法
        System.out.println(getMAX(()->{
            Collections.sort(arr);
            return arr.get(arr.size()-1);
        }));
    }


Consumer接口
java.util.function.Consumer<T>，消费型接口，消费一个数据，数据类型由泛型决定
void accept（T t）

default andThen
作用：
需要两个consumer接口，把两个Consumer接口组合（复制数据），再消费数据
消费顺序为从前到后

public static void main(String[] args) {
        consumerT("naxx",(String name)->{
            System.out.println(new StringBuilder().append(name).reverse().toString());;
        });
    }
    private static void consumerT(String name ,Consumer<String> Icon) {
        Icon.accept(name);
    }





















