redis分布式

高并发

分布式缓存
队列
数据库分布
分离
中间件
[负载均衡]
读多写少使用缓存
MQ 消息队列
批量查询（redis 70w/s批量 12w/s非批量）

[[[future请求合并]]]

IOC/DI iocontrol 反射

spring原理
1. 根据xml找类文件  加载配置文件 Servlet 解析xml，拿到basePackage
初始化相关类，扫描class
[[读取xml]]

2.（请求处理之前）创建对象，（spring bean容器）保存对象
@Controller @Service（附件信息  让spring托管  创建对象）
注解创建语法 public @interface AnnotationName{}
注解用于表示方法的适用范围
没有注解的，spring不进行创建对象

运行：for读取class信息，进行判断
beanIOCContain.put放入对象


3.需要spring创建的对象都创建完毕
判断是否需要注入，实现注入（[[[反射]]]（赋值））
使用注解判断
@Recource（java）@Autowired（spring）

4.DispatcherServlet（）spring解析注解，保存了url和具体的chontroller对象和method方法的映射（hashmap）
@requestMapping

5.初始化HandleMapping，处理url和controller注解的对应关系

spring mvc处理controller层参数
所有http方法交给doDispatch方法处理

6.利用反射机制调用方法
