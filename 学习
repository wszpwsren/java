构造函数无返回值
构造函数在定义时不写返回值
构造函数可以直接声明（获取？）私有变量
但仍需写get/set方法
arraylist 使用基本类型时自动拆箱/自动装箱

静态：存储于父类的（属于父类？）可以供多个对象调用
静态代码块：当第一次用到本类时，静态代码块执行唯一的一次

继承成员变量
直接调用：初始化左边是谁，优先用谁，没有则向上
间接调用：看方法所在类，没有则向上

局部变量：直接写
子类的成员变量：this.
父类的成员变量：super.

成员方法多态[[[编译看左边，运行看右边]]]

继承成员方法
优先new的对象，没有则向上
1.重写（覆写）：继承关系中，方法名一样，参数列表也一样
创建的是子类对象，则优先用子类方法
//@override写在方法前(子类)，用来检测是不是有效的正确覆写
2.子类方法的 返回值 必须小于等于父类方法的返回值范围
3.子类方法的权限必须大于等于父类方法的权限修饰符
//public>protected>default(默认)>private

调用时
super.父类方法名（必须在子类方法中调用？）

构造方法的继承
1.子类构造方法中有一个隐含的super（）调用，即先父类构造，后子类构造
2.子类构造方法可以使用super调用父类的构造函数重载  

this
1.在本类的成员方法中，访问本类的成员变量（super调用父类）
2.在本类的成员方法中，访问本类的另一个成员方法
3.在本类的构造方法中，访问本类的另一个构造方法（仅一句）

子类[[super_class]]标记，指向父类

继承 特征：
1.java语言单继承（一个类的直接父类只能有一个）
2.java可以多级继承
3.父类可以有多个子类


抽象
父类方法不确定如何实现方法体，那么为抽象方法
public abstract void x（）；
抽象方法所在类必须是抽象类
public abstract class x{ }

抽象类不能直接new
需要使用子类继承抽象父类
子类必须覆写抽象父类中的所有抽象方法（实现）
1.子类去掉父类抽象方法中的abstract关键字，然后补上方法体括号
2.创建子类对象使用

注意事项：
1.抽象类不能创建对象
2.抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的
3.抽象类中，不一定包含抽象方法；有抽象方法的一定是抽象类
4.抽象类的子类，必须重写抽象父类的所有的抽象方法

接口当中的抽象方法，修饰符为固定的public abstract（可省略）
接口实现类声明 public class 类名 implements 接口名称
接口实现类名一般为xxxImpl
zy：
如果实现类并没有覆写所有的抽象方法，则实现类必须为抽象类

接口默认方法（java8）
（public） default 返回值类型 方法名（参数）{}
bz：
解决接口升级的问题（新增接口中的抽象方法时，导致实现类不可用）
接口默认方法可以被实现类覆写
【拼接函数模型lamda表达式等】
调用默认方法时，如果实现类中没有，则会向上找接口
默认方法可通过实现类直接调用
默认方法可以被实现类覆写

接口静态方法（java8）
（public） static 返回值类型 方法名（参数）{}
不能通过接口实现类的对象来来调用接口当中的静态方法
调用:接口名称.方法名（参数）；

接口私有方法（java9）
普通私有方法，解决接口内多个默认方法之间的代码重复
private 返回值类型 方法名（参数）{}
静态私有方法，解决接口内多个静态方法之间的代码重复
private static 返回值类型 方法名（参数）{}

bz:
接口当中可以定义“成员变量”，但是必须使用(public static final)修饰，即常量[命名时参考常量命名方式，全大写, _分隔]
zy:
接口当中的变量必须初始化；

zy:接口不能有静态代码块
接口不能有构造方法
一个类只能有唯一的父类
一个类可以实现多个接口
如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆写一次
如果实现类实现的多个接口中，存在重复的默认方法，那么在实现类中必须对方法重写
一个类直接父类当中的方法，和接口当中的默认方法产生冲突，优先使用父类中的方法
[[[继承优先于接口实现]]]
继承优先级 从高到低[[[this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)]]]

[[接口可多继承]]
zy：
1。多个父接口当中的抽象方法可重复
2。多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆写，并该方法带有default修饰

多态Polymorphism（Multi）
extends与implements 是多态性的前提
[[对象]]有多态性
代码中体现多态性为，父类引用指向子类对象
父类名称 对象名 = new 子类名称（）；
接口名称 对象名 = new 实现类名称（）；

对象的向上转型（↑写法）
向上转型一定是安全的
向上转型无法调用子类特有的内容
对象的向下转型 [[还原]]
子类名称 对象名 = （子类名称）父类对象；
zy
1.保证还原，若不还原为原类型，则报错

判断对象是否能当作类型的实例
写法：  对象 instanceof 类型
返回值类型为bool

final
可以用于修饰 类 方法 局部变量 成员变量
修饰类 不能有子类
修饰方法 不能重写
成员变量 需要使用构造方法进行赋值（不能使用默认值），成员方法不能对成员变量进行赋值

权限
                           public    protected   default    private
同类                       y              y               y              y
同包                       y              y               y              n
不同包子类             y              y               n              n
不同包非子类          y               n              n              n 

内部类
1.成员内部类 2.局部内部类（包括3.匿名内部类）
内部类可以访问外部类
外部类访问内部类需要内部类对象
文件名xxx$zz zz为内部类名
使用方式：
1.在外部类的方法当中，使用内部类，（被调用的为外部类方法）
2.直接方式 [[外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）；]]

类的权限修饰符
1.外部类 public/default
2.成员内部类 全可使用
3.局部内部类 什么都不能用（仅本方法可用）

如果局部内部类希望访问方法的局部变量，那么这个局部变量必须是[[有效Final的]]

[[[局部内部类的匿名内部类]]]
[[如果接口的实现类，或父类的子类，只需要使用唯一的一次,那么这种情况下可以省略该类的定义，改为使用匿名内部类]]
接口名称 对象名 = new 接口名称（）{}【；】注意分号
↑[[大括号内部内容为匿名内部类]]
new 接口名称(){}
1.new代表创建对象的动作
2.接口名称为需要实现的接口
3.{}是匿名内部类的内容

1.匿名内部类，在创建对象的时候，只能使用唯一一次（如果希望多次创建对象，必须使用单独定义的实现类）
2.匿名对象匿名内部类
 new 接口名称(){}.method()
在调用方法的时候，只能调用唯一一次（如果希望多次调用，必须起名字）但是对于接口的每个抽象方法都需要实现
3.匿名内部类省略了实现类/子类名称，匿名对象省略了对象名称




———————————————————————————————————————————————


[[直接打印对象的名字，其实就是调用对象的toString]]（打印地址值）
需要打印值则需要覆写toString方法





